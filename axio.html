<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AXIO/1 2025</title>
    <style>
        body {
            margin: 0;
            height: 200vh; /* Make the page scrollable */
            overflow-x: hidden;
            font-family: Arial, sans-serif;
            color: Black;
            background-color: #EFEFFF;
        }

        /* Fixed Canvas Background */
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* Always behind other content */
        }

        /* Content on top */
        .content {
            position: relative;
            z-index: 1;
            padding: 50px;
        }
    </style>
</head>
<body>

    <div class="canvas-container"></div>

    <div class="content">

<aside>
        <H1>AXIO/1</h1>
        <h3>Artificial Experienced Intelligent Ontology v10.0 (2025)</h3>
        <div>Groupoїd Infinity fibrational type systems for
                 mathematical representation, certification (theorem proving),
                 with extraction to verified interpreter and its runtime.
        </div>
        <div>
<ul>
  <li>Українською: Штучна Досвідчена Інтелектуальна Онтологія</li>
  <li>Тибетською: བཟོ་བཀོད་ཀྱི་ཉམས་ཡོད་པའི་རིག་པའི་ངོ་བོ་ལུགས། (bzo bkod kyi nyams yod pa'i rig pa'i ngo bo lugs)</li>
</ul>
        </div>

            <div>2015&mdash;2025 &copy; <a href="https://5ht.co/license/">DHARMA LICENSE</a>
            <br><br></div>
</aside>
<main>
    <section>

<h2>Table of Contents (དཀར་ཆག dkar chag)</h2>
<ul>
    <li>Introduction</li>
    <li>Process</li>
    <li>Components</li>
    <li>Operators</li>
    <li>Refinments</li>
    <li>Goals</li>
    <li>Runtime Languages</li>
    <li>Higher Languages</li>
    <li>Total Verification of Mathematics</li>
</ul>

<h2>1. Introduction (ངོ་སྤྲོད ngo sprod)</h2>
<p>The <strong>AXIO/1 Framework</strong> is a layered system for <strong>infinite reasoning</strong>, structured into:</p>
<ul>
    <li><strong>Runtime Languages</strong>: Execute computations and manage concurrency.</li>
    <li><strong>Higher Languages</strong>: Handle theorem proving and formal verification.</li>
</ul>
<p>This framework operates as a <strong>cyclic, iterative system</strong> for formal reasoning,
   where an <strong>operator</strong> (human, AI, or hybrid) directs a process that continuously refines itself.</p>

<h2>2. Process (ལས་ཀ las ka)</h2>
<p>AXIO/1 follows a structured flow:</p>
<ol>
    <li><strong>Conditions</strong>: Foundational elements (Axioms, Definitions, Types, Propositions, Syntax).</li>
    <li><strong>Environment</strong>: The structured setting (Model, Consistency, Completeness, Library).</li>
    <li><strong>Thinking</strong>: Reasoning mechanisms (Hypotheses, Computation, Deduction, Conjecture, Inference Rules, General Induction).</li>
    <li><strong>Fruit</strong>: Logical results (Proof, Judgment, Theorem).</li>
    <li><strong>Insight</strong>: Higher-level understanding (Semantics, Categorical Frameworks, Abstraction).</li>
</ol>

<h2>3. Components (ཆ་ཤས cha shas)</h2>

<h3>Condition (C) རྐྱེན Умова rkyen</h3>
<code>
    C = (A, D, T, P, X)
</code>
<ul>
    <li><strong>Axioms (A)</strong>: Fundamental truths.</li>
    <li><strong>Definitions (D)</strong>: Precise descriptions of entities.</li>
    <li><strong>Types (T)</strong>: Categorization of objects.</li>
    <li><strong>Syntax (X)</strong>: Structural rules.</li>
</ul>

<h3>Environment (E) ཁོར་ཡུག Середовище khor yug </h3>
<code>
    E = (M, C, K, L)
</code>
<ul>
    <li><strong>Model (M)</strong>: Formal representation of the system.</li>
    <li><strong>Consistency (C)</strong>: No contradictions within the system.</li>
    <li><strong>Completeness (K)</strong>: The extent to which all truths can be derived.</li>
    <li><strong>Library (L)</strong>: Repository of known results.</li>
</ul>

<h3>Reason (T) རྒྱུ Причина rgyu </h3>
<code>
    T = (J, H, C, D, G)
</code>
<ul>
    <li><strong>Judgment (J)</strong>: Logical assertions.</li>
    <li><strong>Hypotheses (H)</strong>: Presupposition, Assumption, Supposition, Proposition.</li>
    <li><strong>Computation (C)</strong>: Lambda Calculus, Pi-Calculus.</li>
    <li><strong>Deduction (D)</strong>: Inference Rules, General Induction.</li>
    <li><strong>Conjecture/Assertion (G)</strong>: Formulation of potential truths.</li>
</ul>

<h3>Fruit (F) འབྲས་བུ Плід 'bras bu</h3>
<code>
    F = (⊢,Θ)
</code>
<ul>
    <li><strong>Proof</strong> ⊢ Verified propositions.</li>
    <li><strong>Theorem</strong> Θ Established truths.</li>
</ul>

<h3>Insight (I) ལྟ་བའི་ཤེས་པ lta ba'i shes pa</h3>
<code>
    I = (S, C, A)
</code>
<ul>
    <li><strong>Semantics</strong> Σ: Meaning assignment.</li>
    <li><strong>Categorical Frameworks </strong> C: High-level abstractions..</li>
    <li><strong>Abstraction</strong> A: Generalization of concepts.</li>
</ul>

<h2>3. Operators (བཀོལ་སྤྱོད་པ bkol spyod pa) </h2>
<p>Three types of operators drive the system:</p>
<ul>
    <li><strong>Human</strong>: Chooses propositions, interprets insights, and guides conjectures.</li>
    <li><strong>Machine</strong>: Automates computations, checks consistency, and suggests hypotheses.</li>
    <li><strong>Hybrid</strong>: Human sets goals, machine executes reasoning steps.</li>
</ul>

<h2>4. Refinements (ལེགས་བཅོས legs bcos) </h2>
<p>Ensuring correctness and progression:</p>
<ul>
    <li><strong>Infinite Thinking</strong>: Achieved via iteration <code>Sₙ → ∞</code>.</li>
    <li><strong>Finite Steps</strong>: Each step is discrete, <code>Sₙ → Sₙ₊₁</code>.</li>
    <li><strong>Operator-Driven</strong>: The direction of reasoning is controlled by <code>O</code>.</li>
</ul>

<p>The cycle repeats indefinitely, refining knowledge.</p>
<code>
    S₀ → S₁ → S₂ → ... → Sₙ → Sₙ₊₁ → ...
</code>
<p>Where:</p>
<ul>
    <li><code>Sₙ</code> is a finite reasoning step.</li>
    <li><code>Sₙ₊₁</code> builds upon <code>Sₙ</code>, ensuring refinement.</li>
    <li><strong>Limit process</strong>: <code>lim (n → ∞) Sₙ</code> represents <strong>infinite reasoning</strong>.</li>
</ul>

<h2>5. Design Goals (དམིགས་ཡུལ dmigs yul)</h2>
<ul>
    <li><strong>Runtime Languages</strong>: Handle computation and concurrency.</li>
    <li><strong>Higher Languages</strong>: Ensure theorem proving and soundness.</li>
    <li><strong>Infinite Thinking</strong>: Achieved via refinements cycles.</li>
    <li><strong>Operator-Driven</strong>: Collaboration between humans and machines.</li>
</ul>

    </section>
    <section>
        <hr>
    </section>
    <section>
        <p>Verified Lambda Interpreter and Concurrent Parallel Matrix Runtime.
           Joe, Bob, and Alice languages share the same Standard ML like BNF grammar.</p>
    </section>
    <section>
        <a name=Joe></a>
        <h3><a href="https://github.com/groupoid/joe">Joe</a></h3>
         <p><b style="sel">Joe</b> is a certified bytecode stack interpreter and Intel/ARM code compiler.</p>
         <P>[1] — MinCaml<br>
            [2] — CoqASM<br>
            [3] — Verified LISP Interpreter<br>
            [4] — Kind<br>
         </p>
        <figure><pre>
fun a (0, n) = n + 1
  | a (m, 0) = a (m - 1, 1)
  | a (m, n) = a (m - 1, a (m, n - 1))
        </pre></figure>
    </section>
    <section>
        <a name=Bob></a>
        <h3><a href="https://github.com/o83/n2o">Bob</a></h3>
         <p><b style="sel">Bob</b> is a parallel concurrent non-blocking
            zero-copy run-time with CAS cursors [4,5].</p>
         <P>[5] — Kernel<br>
            [6] — Pony<br>
            [7] — Erlang<br></p>
        <figure><pre>
fun proc =
let val p0 = pub(0,8)
    val s1 = sub(0,p0)
    val s2 = sub(0,p0)
 in send(p0,11);
    send(p0,12);
    [ receive(s1);
      receive(s2);
      receive(s1);
      receive(s2)
    ]
    end
        </pre></figure>
    </section>
    <section>
        <a name=Alice></a>
        <h3><a href="https://tonpa.guru/stream/2023/2023-09-25%20Formal%20Tensor.htm">Alice</a></h3>
         <p><b style="sel">Alice</b> is a linear types calculus
            with partial fractions [6] for BLAS level 3 programming.</p>
         <P>[8] — NumLin<br> </p>
   <figure><pre>
fun simpleConvolution (i n: int) (x0: float) (write w: vector float)
  : vector float
  = begin
      if n = i then result.emit(write),
      a = [w0,w1,w2] = w.get(0,3),
      b = [x0,x1,x2] = [ x0 | write.get(i,2) ],
      write.set(i, Dotp(a,b)),
      simpleConvolution((i + 1),n,x1,write,w)
    end
     </pre></figure>
    </section>
    <section>
        <hr>
    </section>
    <section>
        <p>Sound and Consistent Predicative Formal Languages.
           Henk, Per, Anders, Dan languages share the same Lean like BNF grammar.</p>
    </section>
    <section>
        <a name=Henk></a>
        <h3><a href="https://github.com/groupoid/henk">Henk</a></h3>
        <p><b style="sel">Henk</b> is a Pure Type System (PTS-91) in
             the style of Coquand/Huet Calculus of Inductive Constructions (CoC-88)
             with infinite numbere of universes. Henk also supports AUTOMATH syntax (AUT-68).</p>
        <p>
           AUT-68 — AUTOMATH<br>
           CoC-88 — Calculus of Constructions<br>
           PTS-91 — Pure Type System (Π)<br>
        </p>

        <figure><pre>
def N := Π (A : U), (A → A) → A → A
def zero : N := λ (A : U) (S : A → A) (Z : A), Z
def succ : N -> N := λ (n : N) (A : U) (S : A → A) (Z : A), S (n A S Z)
def plus (m n : N) : N := λ (A : U) (S : A → A) (Z : A), m A S (n A S Z)
def mult (m n : N) : N := λ (A : U) (S : A → A) (Z : A), m A (n A S) Z
def pow (m n : N) : N := λ (A : U) (S : A → A) (Z : A), n (A → A) (m A) S Z
        </pre></figure>

    </section>
    <section>
        <a name=Per></a>
        <h3><a href="https://github.com/groupoid/per">Per</a></h3>
        <p><b style="sel">Per</b> is a ΠΣ (MLTT-72) prover with Calculus of
           Inductive Constructions and idenitity types (MLTT-75). The natural
           extension of CoC to CIC was done by Frank Pfenning and Christine Paulin (IND-89).</p>
        <p>
           Mini-TT — OCaml implementation<br>
           MLTT-72 — Pi, Sigma<br>
           MLTT-75 — Pi, Sigma, Id<br>
           MLTT-80 — 0, 1, 2, W, Pi, Sigma, Id<br>
           PP-89 — Inductively Defined Types<br>
           CIC-2015 — Calculus of Inductive Constructiions<br>
        </p>
        <figure><pre>
def empty      : U := inductive { }
def L¹ (A : U) : U := inductive { nil | cons (head: A) (tail: L¹ A) }
def S¹         : U := inductive { base | loop : Equ S¹ base base }

def quot (A: U) (R : A -> A -> U) : U
 := inductive { quotient (a: A)
              | identification (a b: A) (r: R a b)
              : Equ (quot A R) (quotient a) (quotient b)
              }
        </pre></figure>
    </section>
    <section>
        <a name=Anders></a>
        <h3><a href="https://github.com/groupoid/anders">Anders</a></h3>
        <p><b style="sel">Anders</b> is a Homotopy Type System (HTS-2013)
           with Strict Equality and Cubical Agda (CCHM-2016) primitives.</p>
        <p>
           HTS-2013 — Homotopy Type System<br>
           BCH-2014 — Cubical Sets<br>
           CCHM-2015 — Cubical Type System<br>
           OP-2016 — Topos Axioms<br>
           CHM-2017 — Huber Equations<br>
           VMA-2017 — Cubical Agda<br>
        </p>
        <figure><pre>
def idfun  (A : U) : A → A := λ (a : A), a
def idfun′ (A : U) : A → A := transp (&lt;i> A) 0
def idfun″ (A : U) : A → A := λ (a : A), hcomp A 0 (λ (i : I), []) a
def isFiberBundle (B: U) (p: B → U) (F: U): U
 := Σ (v: U) (w: surjective v B), (Π (x: v), PathP (&lt;_>U) (p (w.1 x)) F)
def ~~ (X : U) (a x′ : X) : U := Path (ℑ X) (ι X a) (ι X x′)
def 𝔻 (X : U) (a : X) : U := Σ (x′ : X), ~~ X a x′
def unitDisc (X : U) (x : ℑ X) : U := Σ (x′ : X), Path (ℑ X) x (ι X x′)
def starDisc (X : U) (x : X) : 𝔻 X x := (x, idp (ℑ X) (ι X x))
def T∞ (A : U) : U := Σ (a : A), 𝔻 A a
def inf-prox-ap (X Y : U) (f : X → Y) (x x′ : X) (p : ~~ X x x′)
  : ~~ Y (f x) (f x′) := &lt;i> ℑ-app X Y f (p @ i)
def d (X Y : U) (f : X → Y) (x : X) (ε : 𝔻 X x) : 𝔻 Y (f x)
 := (f ε.1, inf-prox-ap X Y f x ε.1 ε.2)
def T∞-map (X Y : U) (f : X → Y) (τ : T∞ X) : T∞ Y
 := (f τ.1, d X Y f τ.1 τ.2)
def is-homogeneous (A : U)
 := Σ (e : A) (t : A → equiv A A),
    Π (x : A), Path A ((t x).1 e) x
         </pre></figure>

    </section>
    <section>
        <a name=Daniel></a>
        <h3><a href="https://github.com/groupoid/dan">Dan</a></h3>
        <p><b style="sel">Dan</b> is a simplicial CCHM-based verification system with
           Simplicial, Simplex, Chain, Monoid, Category, Group primitives built into the type checker core.
           Dan is new Rzk/GAP replacement with Kan, Rezk and Segal simplicial
           modes for computable ∞-categories.
        </p>
        <p>
           R-HoTT — Rezk Infinity Categories<br>
           Hopf-HoTT — Hopf Fibrations, Stable Spherical Homotopy Groups<br>
        </p>
        <figure><pre>
def path_z2_category : Category
 := П (x y : Simplex),
      (f g h : Simplex),
      (z2 : Group(П (e a : Simplex), a² = e ⊢ 1 (a | a² = e))),
      f ∘ g = h
    ⊢ 2 (x y | f g h | f ∘ g = h)

def z3 : Group
 := П (e a : Simplex),
      a³ = e
    ⊢ 1 (a | a³ = e)

def Möbius : Simplex
 := П (a b c : Simplex),
      (bc ac : Simplex), ab = bc ∘ ac
    ⊢ 2 (a b c | bc ac ab)
         </pre></figure>

    </section>
    <section>
        <a name=Jack></a>
        <h3><a href="https://github.com/groupoid/jack">Jack</a></h3>
        <p><b style="sel">Jack</b> is a Minimal Framework for Homotopy Groups of Spheres
           which encompasses unstable homotopy, stable homotopy (e.g., π₀^S(S⁰) = ℤ),
           and chromatic phenomena (e.g., H^*(RP^2), spectral sequences),
           inspired by Morava's chromatic vision. It features HopfFibⁿ (n=1,2,3,4),
           Susp(A), Truncⁿ(A), ℕ, ℕ∞, Π(x:A).B, Σ(x:A).B, Id_A(u, v), Spec, πₙ^S(A),
           S⁰[p], Group, A ∧ B, [A, B], Hⁿ(X; G), G ⊗ H, SS(E, r). It has
           Sⁿ, πₙ(Sᵐ), K(G, n), Cohomology Rings, Chromatic Towers as derivables.
        </p>

        <a name=Urs></a>
        <h3><a href="https://github.com/groupoid/urs">Urs</a></h3>
        <p><b style="sel">Urs</b> is a Framework for Supergeometry in Cohesive Topos.
           It features Graded Universes, Graded Tensor, Group Action, Super Type Theory: Uᵍᵢ| 𝖘 A | 𝔾 → A,
           Super Modality: Γ ⊢ A : Uᵢ^g → Γ ⊢ 𝖘 A : Uᵢ^g, Cohesive Type Theory: ∣ ʃ ∣ ♭ ∣ ♯ ∣ ℑ | & | ℜ .</P>

        <a name=Laurent></a>
        <h3><a href="https://github.com/groupoid/laurent">Laurent</a></h3>
        <p><b style="sel">Julius</b> is a type system for Functional Analysis and Calculus.
          It features ℝ, C, Nat, Boo, Forall, Exists, Set, Measure, Lebesgue. Seq, Inf, Sup, Lim.
            for Real, Complex Functional Analysis, and Calculus</P>

        <a name=Ernst></a>
        <h3><a href="https://github.com/groupoid/ernst">Ernst</a></h3>
	<p><b style="sel">Ernst</b> is a type system for  ZFC LEM theories.
            It features: 𝑉, Pow(𝐴), 𝑥 ∈ 𝐴, 𝐴 ⊆ 𝐵; LEM: ⊢ 𝑃 ∨ ¬𝑃 for Classical Logic Support.</p>

        <a name=Paul></a>
        <h3><a href="https://github.com/groupoid/paul">Paul</a></h3>
	<p><b style="sel">Paul</b> is a type system for Forced Cardinals.
            It features: ⊢ 𝜅 : Card, inaccessible(𝜅), measurable(𝜅), Force(𝑃, 𝐺) : 𝑉 → 𝑉, 𝑝 ⊩ 𝜙,
            Generic filter 𝐺 over a poset 𝑃, yielding a new model 𝑉[𝐺], allowing for
            adjoin reals and control cardinalities or axioms.</p>

        <a name=Fabien></a>
        <h3><a href="https://github.com/groupoid/fabien">Fabien</a></h3>
	<p><b style="sel">Fabien</b> is a Motivic A^1-Homotopy Theory.
            It featues Π,Σ,Path,𝑘:𝑈,0_𝑘,1_𝑘,point_𝑘,𝐴^1:U,point:𝑘→𝐴^1., A^1-contr,
            𝐿_{A^1}:U→𝑈, 𝜂_{A^1}, rec_{A^1}, n-Trunc, 𝑁, Suspension,S^{1,1}, Nisnevich Cover. It derives all
            structural theorems of A^1-Homotopy Theory—such as A^1-connectivity (X×A^1)≅π_n(A^1),
            contractibility of 𝐴^1, and unstable connectivity — while providing a foundation
            for stable A^1-homotopy via suspensions and motivic spheres. Explicitly
            supporting Nisnevich descent, aligning L_{A^1} with sheaf-like properties,
            while keeping k as a placeholder.</p>

        <figure><pre>
def k : U
def 0_k : k
def 1_k : k

def A1 : U := inductive { point : k → A1 }
def 0_A1 : A1 := A1.point 0_k
def 1_A1 : A1 := A1.point 1_k
def A^1-contr (a : A1) : Path A1 a 0_A1 := &lt;i> comp A1 [j : I] a (i ∧ j) 0_A1

def L_A1 (X : U) : U := (i : I) → X
def isA1Local (Y : U) : U
 := isEquiv (λ (y : Y) (a : A1). y : Y × A1 → Y)

def eta_A1 (X : U) (x : X) : L_A1 X := &lt;i> x
def rec_A1 (X Y : U) (f : X → Y) (loc : isA1Local Y) : L_A1 X → Y
 := λ z => comp Y [i : I] (f (z i)) (f (z 0))

def S11 : U
 := inductive { base : S11
              | loop : A1 → Path S11 base base
              | zero : Path S11 (loop 0_A1) (refl base)
              }

def NisCover (X : U) : U
 := inductive {
              | triv : X → NisCover X
              | cover : (U : U) → (f : U → X) → isNisCover f → NisCover X
              }

def isSurjective (X Y : U) (f : X → Y) : Type fibrant
 := ∀ (y : Y), ∃ (x : X), Path Y (f x) y

def isNisCover (X U : U) (f : U → X) : U
 := isSurjective f

def rec_NisCover
    (X : U) (C : NisCover X → U)
    (t : ∀ (x : X), C (NisCover.triv x)) 
    (d : ∀ (U : U) (f : U → X) (h : isNisCover f), C (NisCover.cover U f h))
    (c : NisCover X) : C c
 := match c with
    | NisCover.triv x => t x
    | NisCover.cover U f h => d U f h

def L_A1-NC (X : U) : U
 := Σ (x : (i : I) → X),
    ∀ (c : NisCover X),
    Path X (rec_NisCover (λ x => x) (λ U f h => f (h x).1) c) (x 0)

def isA1Local-NC (X : U) : U
 := ∀ (c : NisCover X),
    isEquiv (rec_NisCover (λ x => x) (λ U f h => f) c)

def eta_A1 (X : U) (x : X) : L_A1-NC X
 := ((&lt;i> x), λ c => refl x)

         </pre></figure>


    </section>
    <section>
        <H2>Total Verification of Mathematics</H2>

        <p><b>Axiomatic Extended Integrated Ordered System for Infinite Structures (AXIOSIS)</b>
           is a novel type theory engineered to mechanically verify all existing
           theorems across mathematics, from classical analysis to modern set
           theory and homotopy. Building on top of advanced frameworks:</p>

<p><ul>
<li><b>Henk Barendregt</b> Type Theory for Pure Dependent Lambda Calculus,</li>
<li><b>Per Martin-Löf</b> Type Theory for Fibrational setting and inductive types,</li>
<li><b>Anders Mörtberg</b> Type Theory for cubical CCHM/CHM/HTS flavor,</li>
<li><b>Dan Kan</b> Simplicial Homotopy Type Theory with Kan, Rezk, Segal simplicial sets,</li>
<li><b>Jack Morava</b> Type Theory for Chromatic Homotopy Theory and K-Theory,</li>
<li><b>Urs Schreiber</b> Type Theory for Equivariant Supergeometry,</li>
<li><b>Fabien Morel</b> Type Theory for A¹-homotopy theory,</li>
<li><b>Laurent Schwartz</b> Type Theory for Functional Analisys and Theory of Distribution,</li>
<li><b>Ernst Zermelo</b> Type Theory for ZFC with LEM, and</li>
<li><b>Paul Cohen</b> Type Theory for cardinals system incorporating large cardinals and forcing;</li></ul></p>

<p>this system synthesis unifies synthetic homotopy, stable homotopy spectra, cohesive geometry, real analysis,
and set-theoretic foundations into a single, computationally verifiable formalism. We demonstrate its
power through key theorems:</p>

<p><ul>
<li>Number Theory: Prime Number Theorem,</li>
<li>Fundamental Theorem of Calculus (Analysis),</li>
<li>Analysis: Lebesgue Dominated Convergence Theorem,</li>
<li>Topology: Poincaré Conjecture (3D),</li>
<li>Algebra: Classification of Finite Simple Groups,</li>
<li>Set Theory: Independence of the Continuum Hypothesis (CH),</li>
<li>Category Theory: Adjoint Functor Theorem,</li>
<li>Homotopy Theory: Adams Conjecture (via K-theory),</li>
<li>Cohesive Homotopy Theory: Brouwer Fixed-Point Theorem,</li>
<li>Consistency of ZFC with Large Cardinals,</li>
<li>Fermat’s Last Theorem,</li>
<li>Large Cardinal Theorem: Martin’s Maximum;</li></ul>

<p>showcasing its ability to span algebraic, analytic, topological, and
foundational domains. The verification systems stands as a candidate for a universal mechanized mathematics platform,
rivaling systems like Cubical Type Theory while extending their scope.
The system achieves a landmark synthesis, unifying synthetic and classical mathematics in a mechanically
verifiable framework. Its type formers—spanning simplicial ∞-categories, stable spectra, cohesive modalities,
reals, ZFC, large cardinals, and forcing — cover all known mathematical domains as of 2025.</p>

        <a name=Mono></a>
        <h3>Monography as Introductory Course</h3>
        <ul><li>Published by Axiosis: <a href="https://axiosis.github.io/books/axio/axio.pdf">axiosis.github.io/books/axio/axio.pdf</a></li>
        <li>AXIO/AXIOSIS Github Organization: <a href="https://github.com/groupoid/">github.com/groupoid/</a></li></ul>
    </section>
    <section>
        <h3>LaTeX</h3>

<figure><pre>
$ cp *.ttf ~/.local/share/fonts
$ sudo apt install texlive-full
$ sudo fc-cache -f
$ fc-match Geometria
$ make
</pre></figure>

        <h3>Sole Copyright</h3>

        <p>Namdak Tonpa</p>

    <section>


</main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.querySelector(".canvas-container").appendChild(renderer.domElement);

        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1500;
        const starVertices = [];

        for (let i = 0; i < starCount; i++) {
            let x = (Math.random() - 0.5) * 1000;
            let y = (Math.random() - 0.5) * 1000;
            let z = (Math.random() - 0.5) * 1000;
            starVertices.push(x, y, z);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 2 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        camera.position.z = 300;

        function animate() {
            requestAnimationFrame(animate);
            stars.rotation.y += 0.001;
            renderer.render(scene, camera);
        }

        function onResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        window.addEventListener("resize", onResize);

        animate();
    </script>

</body>
</html>
